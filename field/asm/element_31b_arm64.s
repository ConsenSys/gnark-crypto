// Code generated by gnark-crypto/generator. DO NOT EDIT.
#include "textflag.h"
#include "funcdata.h"
#include "go_asm.h"

// addVec(qq *uint32, res, a, b *Element, n uint64)
TEXT ·addVec(SB), NOFRAME|NOSPLIT, $0-40
	LDP  qq+0(FP), (R1, R0)
	LDP  a+16(FP), (R2, R3)
	MOVD n+32(FP), R4
	VLD1 0(R1), [V2.S4]     // broadcast q into V2.S4

loop1:
	CBZ    R4, done2
	VLD1.P 16(R2), [V0.S4]
	VLD1.P 16(R3), [V1.S4]
	VADD   V0.S4, V1.S4, V1.S4 // b = a + b
	VSUB   V2.S4, V1.S4, V3.S4 // t = q - b
	VUMIN  V3.S4, V1.S4, V1.S4 // b = min(t, b)
	VST1.P [V1.S4], 16(R0)     // res = b
	SUB    $1, R4, R4
	JMP    loop1

done2:
	RET

// subVec(qq *uint32, res, a, b *Element, n uint64)
TEXT ·subVec(SB), NOFRAME|NOSPLIT, $0-40
	LDP  qLane+0(FP), (R1, R0)
	LDP  a+16(FP), (R2, R3)
	MOVD n+32(FP), R4
	VLD1 0(R1), [V2.S4]        // broadcast q into V2.S4

loop3:
	CBZ    R4, done4
	VLD1.P 16(R2), [V0.S4]
	VLD1.P 16(R3), [V1.S4]
	VSUB   V1.S4, V0.S4, V1.S4 // b = a - b
	VADD   V1.S4, V2.S4, V3.S4 // t = b + q
	VUMIN  V3.S4, V1.S4, V1.S4 // b = min(t, b)
	VST1.P [V1.S4], 16(R0)     // res = b
	SUB    $1, R4, R4
	JMP    loop3

done4:
	RET

// sumVec(t *uint64, a *[]uint32, n uint64) res = sum(a[0...n])
TEXT ·sumVec(SB), NOFRAME|NOSPLIT, $0-24
	VMOVQ $0, $0, V4
	VMOVQ $0, $0, V5
	VMOVQ $0, $0, V6
	VMOVQ $0, $0, V7
	LDP   t+0(FP), (R1, R0)
	MOVD  n+16(FP), R2

loop5:
	CBZ    R2, done6
	VLD2.P 16(R0), [V0.S2, V1.S2]
	VLD2.P 16(R0), [V2.S2, V3.S2]
	VUSHLL $0, V0.S2, V0.D2       // convert to 64 bits
	VUSHLL $0, V1.S2, V1.D2       // convert to 64 bits
	VADD   V0.D2, V4.D2, V4.D2    // acc1 += a1
	VADD   V1.D2, V5.D2, V5.D2    // acc2 += a2
	VUSHLL $0, V2.S2, V2.D2       // convert to 64 bits
	VUSHLL $0, V3.S2, V3.D2       // convert to 64 bits
	VADD   V2.D2, V6.D2, V6.D2    // acc3 += a3
	VADD   V3.D2, V7.D2, V7.D2    // acc4 += a4
	SUB    $1, R2, R2
	JMP    loop5

done6:
	VADD   V4.D2, V6.D2, V4.D2   // acc1 += acc3
	VADD   V5.D2, V7.D2, V5.D2   // acc2 += acc4
	VST2.P [V4.D2, V5.D2], 0(R1) // store acc1 and acc2
	RET
