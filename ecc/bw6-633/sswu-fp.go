// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package bw6633

import (
	"github.com/consensys/gnark-crypto/ecc/bw6-633/fp"
	"math/big"
)

// sqrtRatio computes the square root of u/v and returns true if u/v was indeed a quadratic residue
// if not, we get sqrt(Z * u / v). Recall that Z is non-residue
// Taken from https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/13/ F.2.1.3. q = 5 mod 8
// The main idea is that since the computation of the square root involves taking large powers of u/v, the inversion of v can be avoided
func sqrtRatio(z *fp.Element, u *fp.Element, v *fp.Element) bool {

	var tv1, tv2 fp.Element
	tv1.Square(v)
	tv2.Mul(&tv1, v)
	tv1.Square(&tv1)
	tv2.Mul(&tv2, u)
	tv1.Mul(&tv1, &tv2)

	var c1 big.Int
	c1.SetBytes([]byte{36, 204, 103, 152, 30, 107, 236, 127, 131, 66, 233, 224, 58, 229, 86, 181, 31, 155, 24, 235, 175, 58, 88, 233, 203, 46, 211, 91, 55, 123, 69, 240, 42, 84, 216, 31, 91, 212, 146, 23, 27, 83, 235, 208, 126, 175, 137, 47, 193, 209, 10, 29, 183, 180, 128, 250, 246, 185, 207, 87, 7, 56, 68, 167, 166, 211, 122, 98, 40, 254, 231, 154, 233, 34, 221, 72, 174, 0, 1})
	var y1 fp.Element
	y1.Exp(tv1, &c1)
	y1.Mul(&y1, &tv2)
	tv1.Mul(&y1, &fp.Element{7899625277197386435, 5217716493391639390, 7472932469883704682, 7632350077606897049, 9296070723299766388, 14353472371414671016, 14644604696869838127, 11421353192299464576, 237964513547175570, 46667570639865841})
	tv2.Square(&tv1)

	//Line 10 in std doc
	tv2.Mul(&tv2, v)

	if tv2 == *u {
		y1 = tv1
	}

	tv2.Square(&y1)
	tv2.Mul(&tv2, v)

	//Line 15
	isQr := tv2 == *u
	var y2 fp.Element
	y2.Mul(&y1, &fp.Element{16212120288951005687, 11690167560162600414, 9845362566212292170, 5006379754746321817, 3559960229467473872, 1378556217976105943, 4841104984578141598, 15436992508257808297, 6778583767067406308, 4544728946065242})
	tv1.Mul(&y2, &fp.Element{7899625277197386435, 5217716493391639390, 7472932469883704682, 7632350077606897049, 9296070723299766388, 14353472371414671016, 14644604696869838127, 11421353192299464576, 237964513547175570, 46667570639865841})
	tv2.Square(&tv1)
	tv2.Mul(&tv2, v)

	var tv3 fp.Element
	//Line 20
	// Z = 2
	mulByZ(&tv3, u)
	if tv2 == tv3 {
		y2 = tv1
	}
	if isQr {
		*z = y1
	} else {
		*z = y2
	}

	return isQr
}

//TODO: Use addchain
//TODO: Might duplicate functionality from mulByConst functions
// mulByZ multiplies x by 2 and stores the result in z
func mulByZ(z *fp.Element, x *fp.Element) {

	res := *x

	res.Double(&res)

	*z = res
}

// From https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/13/ Pg 80
func sswuMapG1(u *fp.Element) G1Affine {

	var tv1 fp.Element
	tv1.Square(u)

	//mul tv1 by Z
	mulByZ(&tv1, &tv1)

	var tv2 fp.Element
	tv2.Square(&tv1)
	tv2.Add(&tv2, &tv1)

	var tv3 fp.Element
	//Standard doc line 5
	var tv4 fp.Element
	tv4.SetOne()
	tv3.Add(&tv2, &tv4)
	tv3.Mul(&tv3, &fp.Element{0})

	tv4 = fp.Element{0}
	//TODO: Std doc uses conditional move. If-then-else good enough here?
	if tv2.IsZero() {
		fp.MulBy11(&tv4) //WARNING: this branch takes less time
		//tv4.MulByConstant(Z)
	} else {
		tv4.Mul(&tv4, &tv2)
		tv4.Neg(&tv4)
	}
	tv2.Square(&tv3)

	var tv6 fp.Element
	//Standard doc line 10
	tv6.Square(&tv4)

	var tv5 fp.Element
	tv5.Mul(&tv6, &fp.Element{0})

	tv2.Add(&tv2, &tv5)
	tv2.Mul(&tv2, &tv3)
	tv6.Mul(&tv6, &tv4)

	//Standards doc line 15
	tv5.Mul(&tv6, &fp.Element{0})
	tv2.Add(&tv2, &tv5)

	var x fp.Element
	x.Mul(&tv1, &tv3)

	var y1 fp.Element
	gx1Square := sqrtRatio(&y1, &tv2, &tv6)

	var y fp.Element
	y.Mul(&tv1, u)

	//Standards doc line 20
	y.Mul(&y, &y1)

	//TODO: Not constant time. Is it okay?
	if gx1Square {
		x = tv3
		y = y1
	}

	//TODO: Not constant time
	if u.Sgn0() != y.Sgn0() {
		y.Neg(&y)
	}

	//Standards doc line 25
	//TODO: Not constant time. Use Jacobian?
	x.Div(&x, &tv4)

	return G1Affine{x, y}
}

// EncodeToCurveG1SSWU maps a fp.Element to a point on the curve using the Simplified Shallue and van de Woestijne Ulas map
//https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/13/#section-6.6.3
func EncodeToCurveG1SSWU(msg, dst []byte) (G1Affine, error) {
	var res G1Affine
	t, err := hashToFp(msg, dst, 1)
	if err != nil {
		return res, err
	}
	res = sswuMapG1(&t[0])

	res.ClearCofactor(&res)

	return res, nil
}

// HashToCurveG1SSWU hashes a byte string to the G1 curve. Usable as a random oracle.
// https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-06#section-3
func HashToCurveG1SSWU(msg, dst []byte) (G1Affine, error) {
	var res G1Affine
	u, err := hashToFp(msg, dst, 2)
	if err != nil {
		return res, err
	}

	Q0 := sswuMapG1(&u[0])
	Q1 := sswuMapG1(&u[1])

	var _Q0, _Q1, _res G1Jac
	_Q0.FromAffine(&Q0)
	_Q1.FromAffine(&Q1)
	_res.Set(&_Q1).AddAssign(&_Q0)
	res.FromJacobian(&_res)

	res.ClearCofactor(&res)

	return res, nil
}
