// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fp

// expBySqrtExp is equivalent to z.Exp(x, 1303b8fbbe)
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) expBySqrtExp(x Element) *Element {
	// addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_1100     = _11 << 2
	//	_1111     = _11 + _1100
	//	_111100   = _1111 << 2
	//	_1111000  = 2*_111100
	//	_10110100 = _111100 + _1111000
	//	i11       = 2*_10110100 + _1111000
	//	i12       = 2*i11
	//	i19       = (i12 << 2 + i12) << 3 + _10110100
	//	i20       = i11 + i19
	//	i22       = 2*i20 + i19
	//	i43       = ((i20 + i22) << 14 + i22 + 1) << 4
	//	return      2*(_1111 + i43)
	//
	// Operations: 33 squares 12 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
	)

	// var t0,t1,t2,t3 Element
	// Step 1: z = x^0x2
	z.Square(&x)

	// Step 2: z = x^0x3
	z.Mul(&x, z)

	// Step 4: t0 = x^0xc
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 5: z = x^0xf
	z.Mul(z, t0)

	// Step 7: t0 = x^0x3c
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 8: t1 = x^0x78
	t1.Square(t0)

	// Step 9: t0 = x^0xb4
	t0.Mul(t0, t1)

	// Step 10: t2 = x^0x168
	t2.Square(t0)

	// Step 11: t1 = x^0x1e0
	t1.Mul(t1, t2)

	// Step 12: t2 = x^0x3c0
	t2.Square(t1)

	// Step 14: t3 = x^0xf00
	t3.Square(t2)
	for s := 1; s < 2; s++ {
		t3.Square(t3)
	}

	// Step 15: t2 = x^0x12c0
	t2.Mul(t2, t3)

	// Step 18: t2 = x^0x9600
	for s := 0; s < 3; s++ {
		t2.Square(t2)
	}

	// Step 19: t0 = x^0x96b4
	t0.Mul(t0, t2)

	// Step 20: t1 = x^0x9894
	t1.Mul(t1, t0)

	// Step 21: t2 = x^0x13128
	t2.Square(t1)

	// Step 22: t0 = x^0x1c7dc
	t0.Mul(t0, t2)

	// Step 23: t1 = x^0x26070
	t1.Mul(t1, t0)

	// Step 37: t1 = x^0x981c0000
	for s := 0; s < 14; s++ {
		t1.Square(t1)
	}

	// Step 38: t0 = x^0x981dc7dc
	t0.Mul(t0, t1)

	// Step 39: t0 = x^0x981dc7dd
	t0.Mul(&x, t0)

	// Step 43: t0 = x^0x981dc7dd0
	for s := 0; s < 4; s++ {
		t0.Square(t0)
	}

	// Step 44: z = x^0x981dc7ddf
	z.Mul(z, t0)

	// Step 45: z = x^0x1303b8fbbe
	z.Square(z)

	return z
}

// expByLegendreExp is equivalent to z.Exp(x, 260771f77b)
//
// uses github.com/mmcloughlin/addchain v0.4.0 to generate a shorter addition chain
func (z *Element) expByLegendreExp(x Element) *Element {
	// addition chain:
	//
	//	_10     = 2*1
	//	_11     = 1 + _10
	//	_110    = 2*_11
	//	_1001   = _11 + _110
	//	_1010   = 1 + _1001
	//	_10011  = _1001 + _1010
	//	_11101  = _1010 + _10011
	//	_100110 = _1001 + _11101
	//	i30     = ((_100110 << 10 + _11101) << 2 + _11) << 8
	//	i44     = ((_11101 + i30 + _10) << 6 + _11101) << 5
	//	return    2*(_11101 + i44) + 1
	//
	// Operations: 34 squares 13 multiplies

	// Allocate Temporaries.
	var (
		t0 = new(Element)
		t1 = new(Element)
		t2 = new(Element)
		t3 = new(Element)
	)

	// var t0,t1,t2,t3 Element
	// Step 1: t0 = x^0x2
	t0.Square(&x)

	// Step 2: t1 = x^0x3
	t1.Mul(&x, t0)

	// Step 3: z = x^0x6
	z.Square(t1)

	// Step 4: t2 = x^0x9
	t2.Mul(t1, z)

	// Step 5: z = x^0xa
	z.Mul(&x, t2)

	// Step 6: t3 = x^0x13
	t3.Mul(t2, z)

	// Step 7: z = x^0x1d
	z.Mul(z, t3)

	// Step 8: t2 = x^0x26
	t2.Mul(t2, z)

	// Step 18: t2 = x^0x9800
	for s := 0; s < 10; s++ {
		t2.Square(t2)
	}

	// Step 19: t2 = x^0x981d
	t2.Mul(z, t2)

	// Step 21: t2 = x^0x26074
	for s := 0; s < 2; s++ {
		t2.Square(t2)
	}

	// Step 22: t1 = x^0x26077
	t1.Mul(t1, t2)

	// Step 30: t1 = x^0x2607700
	for s := 0; s < 8; s++ {
		t1.Square(t1)
	}

	// Step 31: t1 = x^0x260771d
	t1.Mul(z, t1)

	// Step 32: t0 = x^0x260771f
	t0.Mul(t0, t1)

	// Step 38: t0 = x^0x981dc7c0
	for s := 0; s < 6; s++ {
		t0.Square(t0)
	}

	// Step 39: t0 = x^0x981dc7dd
	t0.Mul(z, t0)

	// Step 44: t0 = x^0x1303b8fba0
	for s := 0; s < 5; s++ {
		t0.Square(t0)
	}

	// Step 45: z = x^0x1303b8fbbd
	z.Mul(z, t0)

	// Step 46: z = x^0x260771f77a
	z.Square(z)

	// Step 47: z = x^0x260771f77b
	z.Mul(&x, z)

	return z
}
