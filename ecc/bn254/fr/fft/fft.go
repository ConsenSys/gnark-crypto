// Copyright 2020 Consensys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fft

import (
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/internal/parallel"
	"math/big"
	"math/bits"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
)

// Decimation is used in the FFT call to select decimation in time or in frequency
type Decimation uint8

const (
	DIT Decimation = iota
	DIF
)

// parallelize threshold for a single butterfly op, if the fft stage is not parallelized already
const butterflyThreshold = 16

// FFT computes (recursively) the discrete Fourier transform of a and stores the result in a
// if decimation == DIT (decimation in time), the input must be in bit-reversed order
// if decimation == DIF (decimation in frequency), the output will be in bit-reversed order
func (domain *Domain) FFT(a []fr.Element, decimation Decimation, opts ...Option) {

	opt := fftOptions(opts...)

	// find the stage where we should stop spawning go routines in our recursive calls
	// (ie when we have as many go routines running as we have available CPUs)
	maxSplits := bits.TrailingZeros64(ecc.NextPowerOfTwo(uint64(opt.nbTasks)))
	if opt.nbTasks == 1 {
		maxSplits = -1
	}

	// if coset != 0, scale by coset table
	if opt.coset {
		if decimation == DIT {
			// scale by coset table (in bit reversed order)
			parallel.Execute(len(a), func(start, end int) {
				n := uint64(len(a))
				nn := uint64(64 - bits.TrailingZeros64(n))
				for i := start; i < end; i++ {
					irev := int(bits.Reverse64(uint64(i)) >> nn)
					a[i].Mul(&a[i], &domain.CosetTable[irev])
				}
			}, opt.nbTasks)
		} else {
			parallel.Execute(len(a), func(start, end int) {
				for i := start; i < end; i++ {
					a[i].Mul(&a[i], &domain.CosetTable[i])
				}
			}, opt.nbTasks)
		}
	}

	twiddles := domain.Twiddles
	twiddlesStartStage := 0
	if !domain.hasPrecomputedTwiddles {
		// TODO @gbotrel
	}

	switch decimation {
	case DIF:
		difFFT(a, domain.Generator, twiddles, twiddlesStartStage, 0, maxSplits, nil, opt.nbTasks)
	case DIT:
		ditFFT(a, domain.Generator, twiddles, twiddlesStartStage, 0, maxSplits, nil, opt.nbTasks)
	default:
		panic("not implemented")
	}
}

// FFTInverse computes (recursively) the inverse discrete Fourier transform of a and stores the result in a
// if decimation == DIT (decimation in time), the input must be in bit-reversed order
// if decimation == DIF (decimation in frequency), the output will be in bit-reversed order
// coset sets the shift of the fft (0 = no shift, standard fft)
// len(a) must be a power of 2, and w must be a len(a)th root of unity in field F.
func (domain *Domain) FFTInverse(a []fr.Element, decimation Decimation, opts ...Option) {
	opt := fftOptions(opts...)

	// find the stage where we should stop spawning go routines in our recursive calls
	// (ie when we have as many go routines running as we have available CPUs)
	maxSplits := bits.TrailingZeros64(ecc.NextPowerOfTwo(uint64(opt.nbTasks)))
	if opt.nbTasks == 1 {
		maxSplits = -1
	}
	switch decimation {
	case DIF:
		difFFT(a, domain.GeneratorInv, domain.TwiddlesInv, 0, 0, maxSplits, nil, opt.nbTasks)
	case DIT:
		ditFFT(a, domain.GeneratorInv, domain.TwiddlesInv, 0, 0, maxSplits, nil, opt.nbTasks)
	default:
		panic("not implemented")
	}

	// scale by CardinalityInv
	if !opt.coset {
		parallel.Execute(len(a), func(start, end int) {
			for i := start; i < end; i++ {
				a[i].Mul(&a[i], &domain.CardinalityInv)
			}
		}, opt.nbTasks)
		return
	}

	if decimation == DIT {
		parallel.Execute(len(a), func(start, end int) {
			for i := start; i < end; i++ {
				a[i].Mul(&a[i], &domain.CosetTableInv[i]).
					Mul(&a[i], &domain.CardinalityInv)
			}
		}, opt.nbTasks)
		return
	}

	// decimation == DIF, need to access coset table in bit reversed order.
	parallel.Execute(len(a), func(start, end int) {
		n := uint64(len(a))
		nn := uint64(64 - bits.TrailingZeros64(n))
		for i := start; i < end; i++ {
			irev := int(bits.Reverse64(uint64(i)) >> nn)
			a[i].Mul(&a[i], &domain.CosetTableInv[irev]).
				Mul(&a[i], &domain.CardinalityInv)
		}
	}, opt.nbTasks)

}

func difFFT(a []fr.Element, w fr.Element, twiddles [][]fr.Element, twiddlesStartStage, stage, maxSplits int, chDone chan struct{}, nbTasks int) {
	if chDone != nil {
		defer close(chDone)
	}

	n := len(a)
	if n == 1 {
		return
	} else if n == 256 && stage >= twiddlesStartStage {
		kerDIFNP_256(a, twiddles, stage-twiddlesStartStage)
		return
	}
	m := n >> 1

	if stage < twiddlesStartStage {
		// we need to compute the twiddles for this stage on the fly.
		if (m > butterflyThreshold) && (stage < maxSplits) {
			// 1 << stage == estimated used CPUs
			numCPU := nbTasks / (1 << (stage))
			w := w
			parallel.Execute(m, func(start, end int) {
				if start == 0 {
					fr.Butterfly(&a[0], &a[m])
					start++
				}
				var at fr.Element
				at.Exp(w, big.NewInt(int64(start)))
				for i := start; i < end; i++ {
					fr.Butterfly(&a[i], &a[i+m])
					a[i+m].Mul(&a[i+m], &at)
					at.Mul(&at, &w)
				}
			}, numCPU)
		} else {
			// i == 0
			fr.Butterfly(&a[0], &a[m])
			at := w
			for i := 1; i < m; i++ {
				fr.Butterfly(&a[i], &a[i+m])
				a[i+m].Mul(&a[i+m], &at)
				at.Mul(&at, &w)
			}
		}

	} else {
		// if stage < maxSplits, we parallelize this butterfly
		// but we have only numCPU / stage cpus available
		if (m > butterflyThreshold) && (stage < maxSplits) {
			// 1 << stage == estimated used CPUs
			numCPU := nbTasks / (1 << (stage))
			parallel.Execute(m, func(start, end int) {
				for i := start; i < end; i++ {
					fr.Butterfly(&a[i], &a[i+m])
					a[i+m].Mul(&a[i+m], &twiddles[stage-twiddlesStartStage][i])
				}
			}, numCPU)
		} else {
			// i == 0
			fr.Butterfly(&a[0], &a[m])
			for i := 1; i < m; i++ {
				fr.Butterfly(&a[i], &a[i+m])
				a[i+m].Mul(&a[i+m], &twiddles[stage-twiddlesStartStage][i])
			}
		}
	}

	if m == 1 {
		return
	}

	w.Square(&w)
	nextStage := stage + 1
	if stage < maxSplits {
		chDone := make(chan struct{}, 1)
		go difFFT(a[m:n], w, twiddles, twiddlesStartStage, nextStage, maxSplits, chDone, nbTasks)
		difFFT(a[0:m], w, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
		<-chDone
	} else {
		difFFT(a[0:m], w, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
		difFFT(a[m:n], w, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
	}

}

func ditFFT(a []fr.Element, w fr.Element, twiddles [][]fr.Element, twiddlesStartStage, stage, maxSplits int, chDone chan struct{}, nbTasks int) {
	if chDone != nil {
		defer close(chDone)
	}
	n := len(a)
	if n == 1 {
		return
	} else if n == 256 && stage >= twiddlesStartStage {
		kerDITNP_256(a, twiddles, stage-twiddlesStartStage)
		return
	}
	m := n >> 1

	nextStage := stage + 1
	var nextW fr.Element
	nextW.Square(&w)
	if stage < maxSplits {
		// that's the only time we fire go routines
		chDone := make(chan struct{}, 1)
		go ditFFT(a[m:], nextW, twiddles, twiddlesStartStage, nextStage, maxSplits, chDone, nbTasks)
		ditFFT(a[0:m], nextW, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
		<-chDone
	} else {
		ditFFT(a[0:m], nextW, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
		ditFFT(a[m:n], nextW, twiddles, twiddlesStartStage, nextStage, maxSplits, nil, nbTasks)
	}

	if stage < twiddlesStartStage {
		// we need to compute the twiddles for this stage on the fly.
		if (m > butterflyThreshold) && (stage < maxSplits) {
			// 1 << stage == estimated used CPUs
			numCPU := nbTasks / (1 << (stage))
			w := w
			parallel.Execute(m, func(start, end int) {
				if start == 0 {
					fr.Butterfly(&a[0], &a[m])
					start++
				}
				var at fr.Element
				at.Exp(w, big.NewInt(int64(start)))
				for i := start; i < end; i++ {
					a[i+m].Mul(&a[i+m], &at)
					at.Mul(&at, &w)
					fr.Butterfly(&a[i], &a[i+m])
				}
			}, numCPU)

		} else {
			at := w
			fr.Butterfly(&a[0], &a[m])
			for i := 1; i < m; i++ {
				a[i+m].Mul(&a[i+m], &at)
				at.Mul(&at, &w)
				fr.Butterfly(&a[i], &a[i+m])
			}
		}

	} else {
		// if stage < maxSplits, we parallelize this butterfly
		// but we have only numCPU / stage cpus available
		if (m > butterflyThreshold) && (stage < maxSplits) {
			// 1 << stage == estimated used CPUs
			numCPU := nbTasks / (1 << (stage))
			parallel.Execute(m, func(start, end int) {
				for k := start; k < end; k++ {
					a[k+m].Mul(&a[k+m], &twiddles[stage-twiddlesStartStage][k])
					fr.Butterfly(&a[k], &a[k+m])
				}
			}, numCPU)

		} else {
			fr.Butterfly(&a[0], &a[m])
			for k := 1; k < m; k++ {
				a[k+m].Mul(&a[k+m], &twiddles[stage-twiddlesStartStage][k])
				fr.Butterfly(&a[k], &a[k+m])
			}
		}
	}
}

func kerDIFNP_256(a []fr.Element, twiddles [][]fr.Element, stage int) {
	// code unrolled & generated by internal/generator/fft/template/fft.go.tmpl

	for offset := 0; offset < 256; offset += 256 {
		fr.Butterfly(&a[offset], &a[offset+128])
		k := 1
		for i := offset + 1; i < offset+128; i++ {
			fr.Butterfly(&a[i], &a[i+128])
			a[i+128].Mul(&a[i+128], &twiddles[stage+0][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 128 {
		fr.Butterfly(&a[offset], &a[offset+64])
		k := 1
		for i := offset + 1; i < offset+64; i++ {
			fr.Butterfly(&a[i], &a[i+64])
			a[i+64].Mul(&a[i+64], &twiddles[stage+1][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 64 {
		fr.Butterfly(&a[offset], &a[offset+32])
		k := 1
		for i := offset + 1; i < offset+32; i++ {
			fr.Butterfly(&a[i], &a[i+32])
			a[i+32].Mul(&a[i+32], &twiddles[stage+2][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 32 {
		fr.Butterfly(&a[offset], &a[offset+16])
		k := 1
		for i := offset + 1; i < offset+16; i++ {
			fr.Butterfly(&a[i], &a[i+16])
			a[i+16].Mul(&a[i+16], &twiddles[stage+3][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 16 {
		fr.Butterfly(&a[offset], &a[offset+8])
		k := 1
		for i := offset + 1; i < offset+8; i++ {
			fr.Butterfly(&a[i], &a[i+8])
			a[i+8].Mul(&a[i+8], &twiddles[stage+4][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 8 {
		fr.Butterfly(&a[offset], &a[offset+4])
		k := 1
		for i := offset + 1; i < offset+4; i++ {
			fr.Butterfly(&a[i], &a[i+4])
			a[i+4].Mul(&a[i+4], &twiddles[stage+5][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 4 {
		fr.Butterfly(&a[offset], &a[offset+2])
		k := 1
		for i := offset + 1; i < offset+2; i++ {
			fr.Butterfly(&a[i], &a[i+2])
			a[i+2].Mul(&a[i+2], &twiddles[stage+6][k])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 2 {
		fr.Butterfly(&a[offset], &a[offset+1])
	}
}

func kerDITNP_256(a []fr.Element, twiddles [][]fr.Element, stage int) {
	// code unrolled & generated by internal/generator/fft/template/fft.go.tmpl

	for offset := 0; offset < 256; offset += 2 {
		fr.Butterfly(&a[offset], &a[offset+1])
	}
	for offset := 0; offset < 256; offset += 4 {
		fr.Butterfly(&a[offset], &a[offset+2])
		k := 1
		for i := offset + 1; i < offset+2; i++ {
			a[i+2].Mul(&a[i+2], &twiddles[stage+6][k])
			fr.Butterfly(&a[i], &a[i+2])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 8 {
		fr.Butterfly(&a[offset], &a[offset+4])
		k := 1
		for i := offset + 1; i < offset+4; i++ {
			a[i+4].Mul(&a[i+4], &twiddles[stage+5][k])
			fr.Butterfly(&a[i], &a[i+4])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 16 {
		fr.Butterfly(&a[offset], &a[offset+8])
		k := 1
		for i := offset + 1; i < offset+8; i++ {
			a[i+8].Mul(&a[i+8], &twiddles[stage+4][k])
			fr.Butterfly(&a[i], &a[i+8])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 32 {
		fr.Butterfly(&a[offset], &a[offset+16])
		k := 1
		for i := offset + 1; i < offset+16; i++ {
			a[i+16].Mul(&a[i+16], &twiddles[stage+3][k])
			fr.Butterfly(&a[i], &a[i+16])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 64 {
		fr.Butterfly(&a[offset], &a[offset+32])
		k := 1
		for i := offset + 1; i < offset+32; i++ {
			a[i+32].Mul(&a[i+32], &twiddles[stage+2][k])
			fr.Butterfly(&a[i], &a[i+32])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 128 {
		fr.Butterfly(&a[offset], &a[offset+64])
		k := 1
		for i := offset + 1; i < offset+64; i++ {
			a[i+64].Mul(&a[i+64], &twiddles[stage+1][k])
			fr.Butterfly(&a[i], &a[i+64])
			k++
		}
	}
	for offset := 0; offset < 256; offset += 256 {
		fr.Butterfly(&a[offset], &a[offset+128])
		k := 1
		for i := offset + 1; i < offset+128; i++ {
			a[i+128].Mul(&a[i+128], &twiddles[stage+0][k])
			fr.Butterfly(&a[i], &a[i+128])
			k++
		}
	}
}
