// Copyright 2020-2024 Consensys Software Inc.
// Licensed under the Apache License, Version 2.0. See the LICENSE file for details.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package kzg

import (
	"encoding/binary"
	curve "github.com/consensys/gnark-crypto/ecc/bls12-377"
	"github.com/consensys/gnark-crypto/ecc/bls12-377/mpcsetup"
	"io"
)

type MpcSetup struct {
	srs   SRS
	proof mpcsetup.UpdateProof
}

func InitializeSetup(N int) MpcSetup {
	var res MpcSetup
	_, _, g1, g2 := curve.Generators()

	res.srs.Pk.G1 = make([]curve.G1Affine, N)
	for i := range N {
		res.srs.Pk.G1[i] = g1
	}
	res.srs.Vk.G1 = g1
	res.srs.Vk.G2[0] = g2
	res.srs.Vk.G2[1] = g2

	return res
}

// WriteTo implements io.WriterTo
func (s *MpcSetup) WriteTo(w io.Writer) (int64, error) {
	n, err := s.proof.WriteTo(w)
	if err != nil {
		return n, err
	}
	if err = binary.Write(w, binary.BigEndian, uint64(len(s.srs.Pk.G1))); err != nil {
		return -1, err // binary.Write doesn't return the number written in case of failure
	}
	n += 8
	enc := curve.NewEncoder(w)
	for i := range s.srs.Pk.G1[1:] {
		if err = enc.Encode(&s.srs.Pk.G1[i+1]); err != nil {
			return n + enc.BytesWritten(), err
		}
	}
	err = enc.Encode(&s.srs.Vk.G2[1])
	return n + enc.BytesWritten(), err
}

// ReadFrom implements io.ReaderFrom
func (s *MpcSetup) ReadFrom(r io.Reader) (int64, error) {
	n, err := s.proof.ReadFrom(r)
	if err != nil {
		return n, err
	}
	var N uint64
	if err = binary.Read(r, binary.BigEndian, &N); err != nil {
		return -1, err
	}
	_, _, g1, g2 := curve.Generators()
	n += 8
	dec := curve.NewDecoder(r)
	s.srs.Pk.G1 = make([]curve.G1Affine, N)
	s.srs.Pk.G1[0] = g1
	s.srs.Vk.G2[0] = g2
	for i := range N - 1 {
		if err = dec.Decode(&s.srs.Pk.G1[i+1]); err != nil {
			return n + dec.BytesRead(), err
		}
	}
	err = dec.Decode(&s.srs.Vk.G2[1])
	return n + dec.BytesRead(), err
}

func (s *MpcSetup) Contribute() {

	s.proof = mpcsetup.UpdateValues(nil, nil, 0, &s.srs.Vk.G2[1])
}
