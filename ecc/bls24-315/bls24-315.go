package bls24315

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark-crypto/ecc/bls24-315/fp"
	"github.com/consensys/gnark-crypto/ecc/bls24-315/fr"
	"github.com/consensys/gnark-crypto/ecc/bls24-315/internal/fptower"
)

// TODO: endo needed for clearing cofactor (https://eprint.iacr.org/2017/419.pdf, Appendix A)

// E: y**2=x**3+1
// Etwist: y**2 = x**3+u**-1
// Tower: Fp->Fp2, u**2=13 -> Fp4, v**2=u -> Fp8, w**2=v -> Fp24, i**3=w
// Generator (BLS24 family): x=-0xbfcfffff (32 bits)
// optimal Ate loop: trace(frob)-1=x
// trace of pi: x+1
// Fp: p=0x4c23a02b586d650d3f7498be97c5eafdec1d01aa27a1ae0421ee5da52bde5026fe802ff40300001 (315 bits)
// Fr: r=0x196deac24a9da12b25fc7ec9cf927a98c8c480ece644e36419d0c5fd00c00001 (253 bits)

// ID bls315 ID
const ID = ecc.BLS24_315

// bCurveCoeff b coeff of the curve
var bCurveCoeff fp.Element

// twist
var twist fptower.E4

// bTwistCurveCoeff b coeff of the twist (defined over Fp4) curve
var bTwistCurveCoeff fptower.E4

// twoInv 1/2 mod p (needed for DoubleStep in Miller loop)
var twoInv fp.Element

// generators of the r-torsion group, resp. in ker(pi-id), ker(Tr)
var g1Gen G1Jac
var g2Gen G2Jac

var g1GenAff G1Affine
var g2GenAff G2Affine

// point at infinity
var g1Infinity G1Jac
var g2Infinity G2Jac

// optimal Ate loop counter (=trace-1 = x in BLS24 family)
var loopCounter [33]int8
var finalExponent big.Int

// Parameters useful for the GLV scalar multiplication. The third roots define the
//  endomorphisms phi1 and phi2 for <G1Affine> and <G2Affine>. lambda is such that <r, phi-lambda> lies above
// <r> in the ring Z[phi]. More concretely it's the associated eigenvalue
// of phi1 (resp phi2) restricted to <G1Affine> (resp <G2Affine>)
// cf https://www.cosic.esat.kuleuven.be/nessie/reports/phase2/GLV.pdf
var thirdRootOneG1 fp.Element
var thirdRootOneG2 fp.Element
var lambdaGLV big.Int

// glvBasis stores R-linearly independant vectors (a,b), (c,d)
// in ker((u,v)->u+vlambda[r]), and their determinant
var glvBasis ecc.Lattice

/*
// psi o pi o psi**-1, where psi:E->E' is the degree 6 iso defined over Fp24
var endo struct {
	u fptower.E4
	v fptower.E4
}
*/

// generator of the curve
var xGen big.Int

// expose the tower -- github.com/consensys/gnark uses it in a gnark circuit

// E2 is a degree two finite field extension of fp.Element
type E2 = fptower.E2

// E4 is a degree two finite field extension of fp2
type E4 = fptower.E4

// E8 is a degree two finite field extension of fp4
// type E8 = fptower.E8

// E24 is a degree three finite field extension of fp8
// type E24 = fptower.E24

func init() {

	bCurveCoeff.SetUint64(1)
	twist.B1.SetOne()
	bTwistCurveCoeff.Inverse(&twist)

	twoInv.SetOne().Double(&twoInv).Inverse(&twoInv)

	// E(1,y)*c
	g1Gen.X.SetString("34223510504517033132712852754388476272837911830964394866541204856091481856889569724484362330263")
	g1Gen.Y.SetString("24215295174889464585413596429561903295150472552154479431771837786124301185073987899223459122783")
	g1Gen.Z.SetString("1")

	// E'(5,y)*c'
	g2Gen.X.B0.SetString("24614737899199071964341749845083777103809664018538138889239909664991294445469052467064654073699",
		"17049297748993841127032249156255993089778266476087413538366212660716380683149731996715975282972")
	g2Gen.X.B1.SetString("11950668649125904104557740112865942804623051114821811669564995102755430514441092495782202668342",
		"3603055379462539802413979855826194299714805833759849528529386570240639115620788686893505938793")
	g2Gen.Y.B0.SetString("31740092748246070457677943092194030978994615503726570180895475408200863271773078192139722193079",
		"30261413948955264769241509843031153941332801192447678605718183215275065425758214858190865971597")
	g2Gen.Y.B1.SetString("14195825602561496219090410113749222574308144851497375443809100117082380611212823440674391088885",
		"2391152940984805871402135750194189812615420966694899795235607856168224901793030297133493038211")
	g2Gen.Z.B0.SetString("1",
		"0")
	g2Gen.Z.B1.SetString("0",
		"0")

	g1GenAff.FromJacobian(&g1Gen)
	g2GenAff.FromJacobian(&g2Gen)

	g1Infinity.X.SetOne()
	g1Infinity.Y.SetOne()
	g2Infinity.X.SetOne()
	g2Infinity.Y.SetOne()

	thirdRootOneG1.SetString("39705142672498995661671850106945620852186608752525090699191017895721506694646055668218723303426") // -x^9+3x^8-4x^7+4x^6-3x^5+2x^3-2x^2+x-2 ((-1+tx/yx)/2 mod px)
	thirdRootOneG2.Square(&thirdRootOneG1)
	lambdaGLV.SetString("11502027791375260645628074404575422496066855707288983427913398978447461580801", 10) // x^8
	_r := fr.Modulus()
	ecc.PrecomputeLattice(_r, &lambdaGLV, &glvBasis)

	/*
		endo.u.A0.SetString("")
		endo.v.A0.SetString("")
	*/

	// binary decomposition of 3218079743 little endian
	optimaAteLoop, _ := new(big.Int).SetString("3218079743", 10)
	ecc.NafDecomposition(optimaAteLoop, loopCounter[:])

	xGen.SetString("3218079743", 10)

	finalExponent.SetString("20490278389695127592440755924122635228373068171423020464796633028894728390984194549814310333958403559284510573200502661302626168582150425570617957226835330624126619172576011183618167438982567288828420585441251390750555642131544607587023149608726703192272085281857516819114394647721559184580926700610124451921139657118856986094002548465246792839572788039864195912357251159377088713962593366582131510237840280764152412433141226457963704460999221956123954334386391907249738551107516393548968695264192362731515196505714900201212209543376953345198358858705338484021370805188485728460070599542749459506892428006171051596823485997905680141550478740803568350692821688940383974224723447625777028371172993011190698198946018034173608870910869215177857309567388710527562883467294220418477913159429087543748744191826536384758251163242583731057217369233186013944260935428921117211970388097065641838223779825608321311741287103634038683267733224099091174184712052650463820570857563398052756589927725951555712987628353271815694343655376049340404768056235305679167663605521913513693575400760431625127010194869420090161159397234396674035222736220306951058996358847780715298678242804949746008838721766690723761237220507987255070022976298234128766998636657623507522147128596594786105248392698817833788309672949416537554152155728152702714866845416459100192752430416141443999640607248743070674279001206411806803261444210375679028278158711351674131053569425411801973326825606658615031263044199910938834203884924477394310354852920571757423155324366571791412885469098113500859388649352040031627996526891221417980322610937457812585297296346888068786664040130787338149071492345325535396944929766918548506118736410567838879944526696119012198882010221407682630605174861996852207811926389760776751883212921813590771495820063248333158305230001011580790519541244473380036092705305180790648653866491899619024237547436612037969726781059589464661383359938391734654784540061602793736588613496837065862142790326259657840346491896167577523093780552013446106935214588747590344814027998224935108254930146653998937267474327421519180260618611705085041134589073716572305574001159485077409090249804581707894145595358172157071271057392926720", 10) // (p^24-1)/r

}

// Generators return the generators of the r-torsion group, resp. in ker(pi-id), ker(Tr)
func Generators() (g1Jac G1Jac, g2Jac G2Jac, g1Aff G1Affine, g2Aff G2Affine) {
	g1Aff = g1GenAff
	g2Aff = g2GenAff
	g1Jac = g1Gen
	g2Jac = g2Gen
	return
}
