import (
    "github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
)

{{ define "eval_poly" }}
{{/*arguments: destination, monic, coefficients, variable*/}}
*{{$.dst}} = fp.Element{ {{printList (last $.coefficients)}} }

{{ if $.monic }}
{{$.dst}}.Add({{$.dst}}, {{$.x}})
{{ end }}

{{$coeffsRev := reverse $.coefficients}}
{{- range $c := slice $coeffsRev 1}}
{{$.dst}}.Mul({{$.dst}}, {{$.x}})
{{$.dst}}.Add({{$.dst}}, &fp.Element{ {{printList $c}} })
{{- end}}
{{end}}

{{ if notNil $.HashE1.Isogeny }}

func isogenyXNumerator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        false,
        []fp.Element {
            {{- range $c := $.HashInfoE1.Isogeny.XMap.Num}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyXDenominator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        true,
        []fp.Element {
            {{- range $c := $.HashInfoE1.Isogeny.XMap.Den}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyYNumerator(dst *fp.Element, x *fp.Element, y *fp.Element) {
    var _dst fp.Element
    _dst.EvalPolynomial(
        false,
        []fp.Element {
            {{- range $c := $.HashInfoE1.Isogeny.YMap.Num}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)

   dst.Mul(&_dst, y)
}

func isogenyYDenominator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        true,
        []fp.Element {
            {{- range $c := $.HashInfoE1.Isogeny.YMap.Den}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyG1(p *G1Affine) {

	den := make([]fp.Element, 2)

	isogenyYDenominator(&den[1], &p.X)
	isogenyXDenominator(&den[0], &p.X)

	isogenyYNumerator(&p.Y, &p.X, &p.Y)
	isogenyXNumerator(&p.X, &p.X)

	den = fp.BatchInvert(den)

	p.X.Mul(&p.X, &den[0])
	p.Y.Mul(&p.Y, &den[1])
}

{{ end }}