import (
    "github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
)

{{ define "eval_poly" }}
{{/*arguments: destination, monic, coefficients, variable*/}}
*{{$.dst}} = fp.Element{ {{printList (last $.coefficients)}} }

{{ if $.monic }}
{{$.dst}}.Add({{$.dst}}, {{$.x}})
{{ end }}

{{$coeffsRev := reverse $.coefficients}}
{{- range $c := slice $coeffsRev 1}}
{{$.dst}}.Mul({{$.dst}}, {{$.x}})
{{$.dst}}.Add({{$.dst}}, &fp.Element{ {{printList $c}} })
{{- end}}
{{end}}

{{ if notNil $.HashInfo.E1Prime }}

func isogenyXNumerator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        false,
        []fp.Element {
            {{- range $c := $.HashInfo.E1Prime.XMap.Num}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyXDenominator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        true,
        []fp.Element {
            {{- range $c := $.HashInfo.E1Prime.XMap.Den}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyYNumerator(dst *fp.Element, x *fp.Element, y *fp.Element) {
    var _dst fp.Element
    _dst.EvalPolynomial(
        false,
        []fp.Element {
            {{- range $c := $.HashInfo.E1Prime.YMap.Num}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)

   dst.Mul(&_dst, y)
}

func isogenyYDenominator(dst *fp.Element, x *fp.Element) {
    dst.EvalPolynomial(
        true,
        []fp.Element {
            {{- range $c := $.HashInfo.E1Prime.YMap.Den}}
                { {{ printList $c }} },
            {{- end}}
        },
        x)
}

func isogenyG1(p *G1Affine) {

	den := make([]fp.Element, 2)

	isogenyYDenominator(&den[1], &p.X)
	isogenyXDenominator(&den[0], &p.X)

	isogenyYNumerator(&p.Y, &p.X, &p.Y)
	isogenyXNumerator(&p.X, &p.X)

	den = fp.BatchInvert(den)

	p.X.Mul(&p.X, &den[0])
	p.Y.Mul(&p.Y, &den[1])
}

{{ end }}

// From https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/13/ Pg 80
func sswuMapG1(u *fp.Element) G1Affine {

	var A fp.Element
	var B fp.Element

	A.SetHex("144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")
	B.SetHex("12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")

	var tv1 fp.Element
	tv1.Square(u)

	//mul tv1 by Z
	fp.MulBy11(&tv1)

	var tv2 fp.Element
	tv2.Square(&tv1)
	tv2.Add(&tv2, &tv1)

	var tv3 fp.Element
	//Standard doc line 5
	var tv4 fp.Element
	tv4.SetOne()
	tv3.Add(&tv2, &tv4)
	tv3.Mul(&tv3, &B)
	//tv3.Mul(&tv3, &fp.Element{b10, b11, b12, b13, b14, b15})

	tv4 = A
	//tv4 := fp.Element{a10, a11, a12, a13, a14, a15}
	//TODO: Std doc uses conditional move. If-then-else good enough here?
	if tv2.IsZero() {
		fp.MulBy11(&tv4) //WARNING: this branch takes less time
		//tv4.MulByConstant(Z)
	} else {
		tv4.Mul(&tv4, &tv2)
		tv4.Neg(&tv4)
	}
	tv2.Square(&tv3)

	var tv6 fp.Element
	//Standard doc line 10
	tv6.Square(&tv4)

	var tv5 fp.Element
	tv5.Mul(&tv6, &A)
	//tv5.Mul(&tv6, &fp.Element{a10, a11, a12, a13, a14, a15})

	tv2.Add(&tv2, &tv5)
	tv2.Mul(&tv2, &tv3)
	tv6.Mul(&tv6, &tv4)

	//Standards doc line 15
	tv5.Mul(&tv6, &B)
	//tv5.Mul(&tv6, &fp.Element{b10, b11, b12, b13, b14, b15})
	tv2.Add(&tv2, &tv5)

	var x fp.Element
	x.Mul(&tv1, &tv3)

	var y1 fp.Element
	gx1Square := sqrtRatio(&y1, &tv2, &tv6)

	var y fp.Element
	y.Mul(&tv1, u)

	//Standards doc line 20
	y.Mul(&y, &y1)

	//TODO: Not constant time. Is it okay?
	if gx1Square {
		x = tv3
		y = y1
	}

	//TODO: Not constant time
	if u.Sgn0() != y.Sgn0() {
		y.Neg(&y)
	}

	//Standards doc line 25
	//TODO: Not constant time. Use Jacobian?
	x.Div(&x, &tv4)

	return G1Affine{x, y}
}