{{ $CoordType := .G1.CoordType }}

import (
    "github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
	{{- if or (eq $CoordType "fptower.E2") (eq $CoordType "fptower.E4") }}
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/internal/fptower"
	{{else}}
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
	{{- end}}
	"testing"
)

func TestSqrtRatio(t *testing.T) {
	testSqrtRatio(& {{$CoordType}}{0}, &{{$CoordType}}{1}, t)
	testSqrtRatio(&{{$CoordType}}{1}, &{{$CoordType}}{1}, t)

	for i := 0; i < 1000; i++ {
		var u {{$CoordType}}
		var v {{$CoordType}}
		u.SetRandom()
		v.SetRandom()
		testSqrtRatio(&u, &v, t)
	}
}

func testSqrtRatio(u *{{$CoordType}}, v *{{$CoordType}}, t *testing.T) {
	var ref {{$CoordType}}
	ref.Div(u, v)
	var qrRef bool
	if ref.Legendre() == -1 {
        var Z {{$CoordType}}
        Z.SetUint64({{$.HashInfoE1.Z}})
		ref.Mul(&ref, &Z)
		qrRef = false
	} else {
		qrRef = true
	}

	var seen {{$CoordType}}
	qr := sqrtRatio(&seen, u, v)
	seen.Square(&seen)

	if !ref.IsZero() && qr != qrRef || seen != ref {
        // Allowing qr(0)=false because the generic algorithm "for any field" seems to think so
		t.Error(*u, *v, "actual qr =", qr)
	}
}