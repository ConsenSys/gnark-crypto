{{ $G1TAffine := print (toUpper .G1.PointName) "Affine" }}
{{ $G1TJacobian := print (toUpper .G1.PointName) "Jac" }}
{{ $G1TJacobianExtended := print (toLower .G1.PointName) "JacExtended" }}

{{ $G2TAffine := print (toUpper .G2.PointName) "Affine" }}
{{ $G2TJacobian := print (toUpper .G2.PointName) "Jac" }}
{{ $G2TJacobianExtended := print (toLower .G2.PointName) "JacExtended" }}


import (
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/fp"
	{{- if ne .G1.CoordType .G2.CoordType}}
	"github.com/consensys/gnark-crypto/ecc/{{.Name}}/internal/fptower"
	{{- end}}
)






{{ template "multiexp" dict "CoordType" .G1.CoordType "PointName" .G1.PointName "UPointName" (toUpper .G1.PointName) "TAffine" $G1TAffine "TJacobian" $G1TJacobian "TJacobianExtended" $G1TJacobianExtended "FrNbWords" .Fr.NbWords "CRange" .G1.CRange "LastCRange" .G1.LastCRange}}
{{ template "multiexp" dict "CoordType" .G2.CoordType "PointName" .G2.PointName "UPointName" (toUpper .G2.PointName) "TAffine" $G2TAffine "TJacobian" $G2TJacobian "TJacobianExtended" $G2TJacobianExtended "FrNbWords" .Fr.NbWords "CRange" .G2.CRange "LastCRange" .G2.LastCRange}}



{{define "multiexp" }}

type batchOp{{ $.TAffine }} struct {
	bucketID uint16
	// pointID uint32
	point {{ $.TAffine }}
}

func (o batchOp{{ $.TAffine }}) isNeg() bool {
	return false
	// return o.pointID&1 == 1
}

// processChunk{{ $.UPointName }}BatchAffine process a chunk of the scalars during the msm
// using affine coordinates for the buckets. To amortize the cost of the inverse in the affine addition
// we use a batch affine addition.
// 
// this is derived from a PR by 0x0ece : https://github.com/ConsenSys/gnark-crypto/pull/249
// See Section 5.3: ia.cr/2022/1396
func processChunk{{ $.UPointName }}BatchAffine[BJE ib{{ $.TJacobianExtended }},B ib{{ $.TAffine }}, BS bitSet, TP p{{ $.TAffine }}, TPP pp{{ $.TAffine }}, TQ qOps{{ $.TAffine }}, TC c{{ $.TAffine}}](
	 chunk uint64,
	 chRes chan<- {{ $.TJacobianExtended }},
	 c uint64,
	 points []{{ $.TAffine }},
	 digits []uint16) {

	// init the buckets
	var buckets B
	var bucketsJE BJE
	var bucketSet BS
	for i := 0; i < len(buckets); i++ {
		buckets[i].setInfinity()
		bucketsJE[i].setInfinity()
	}

	// setup for the batch affine;
	var (
		bucketIds BS // bitSet to signify presence of a bucket in current batch
		cptAdd int // count the number of bucket + point added to current batch
		R TPP // bucket references 
		P TP // points to be added to R (buckets); it is beneficial to store them on the stack (ie copy)
		queue TQ // queue of points that conflict the current batch
		qID int // current position in queue
	)
	// var queue [batchSize]batchOp{{ $.TAffine}}
	
	batchSize := len(P)
	
	
	isFull := func() bool {
		return cptAdd == batchSize
	}

	executeAndReset := func ()  {
		batchAdd{{ $.TAffine }}[TP, TPP, TC](&R, &P, cptAdd)
		var tmp BS
		bucketIds = tmp
		cptAdd = 0
	}
	addFromQueue := func(op batchOp{{ $.TAffine }}) {
		// @precondition: ensures bucket is not "used" in current batch
		BK := &buckets[op.bucketID]
		// handle special cases with inf or -P / P
		if !bucketSet[op.bucketID]  {
			bucketSet[op.bucketID] = true
			BK.Set(&op.point)
			return
		}
		if BK.X.Equal(&op.point.X) {
			if BK.Y.Equal(&op.point.Y) {
				// P + P: doubling, which should be quite rare --
				// TODO FIXME @gbotrel / @yelhousni this path is not taken by our tests.
				// need doubling in affine implemented ?
				BK.Add(BK, BK)
				return
			}
			BK.setInfinity()
			bucketSet[op.bucketID] = false
			return
		}

		bucketIds[op.bucketID] = true
		R[cptAdd] = BK
		P[cptAdd] = op.point
		cptAdd++
	}

	add := func(bucketID uint16, PP *{{$.TAffine}}, isAdd bool) {
		// @precondition: ensures bucket is not "used" in current batch
		BK := &buckets[bucketID]
		// handle special cases with inf or -P / P
		if !bucketSet[bucketID]  {
			if isAdd {
				BK.Set(PP)
			} else {
				BK.Neg(PP)
			}
			bucketSet[bucketID] = true
			return
		}
		if BK.X.Equal(&PP.X) {
			if BK.Y.Equal(&PP.Y) {
				// P + P: doubling, which should be quite rare --
				// TODO FIXME @gbotrel / @yelhousni this path is not taken by our tests.
				// need doubling in affine implemented ?
				if isAdd {
					BK.Add(BK, BK)
				} else {
					BK.setInfinity()	
					bucketSet[bucketID] = false	
				}
				
				return
			}
			if isAdd {
				BK.setInfinity()
				bucketSet[bucketID] = false
			} else {
				BK.Add(BK, BK)
			}
			return
		}
		
		bucketIds[bucketID] = true
		R[cptAdd] = BK
		if isAdd {
			P[cptAdd].Set(PP)
		} else {
			P[cptAdd].Neg(PP)
		}
		cptAdd++
	}

	flushQueue := func () {
		for i:=0; i < qID; i++ {
			bucketsJE[queue[i].bucketID].addMixed(&queue[i].point)
		}
		qID = 0
	}

	processQueue := func () {
		for i := qID - 1; i >= 0; i-- {
			if bucketIds[queue[i].bucketID] {
				return
			}
			addFromQueue(queue[i])
			// add(queue[i].bucketID, &points[queue[i].pointID >> 1], !queue[i].isNeg())
			// if isFull() {
			// 	executeAndReset()
			// }
			// queue[i] = queue[qID-1]
			qID--
		}
	}


	for i, digit := range digits {

		if digit == 0 || points[i].IsInfinity() {
			continue
		}

		bucketID := uint16((digit>>1))
		isAdd := digit&1 == 0
		if isAdd {
			// add
			bucketID-=1
		}

		if bucketIds[bucketID] {
			// put it in queue
			queue[qID].bucketID = bucketID
			if isAdd {
				// queue[qID].pointID = uint32(i << 1)
				queue[qID].point.Set(&points[i])	
			} else {
				// queue[qID].pointID = uint32(i << 1) + 1
				queue[qID].point.Neg(&points[i])
			}
			qID++

			// queue is full, flush it.
			if qID == len(queue) - 1 {
				flushQueue()
			}
			continue
		}

		// we add the point to the batch.
		add(bucketID, &points[i], isAdd)
		if isFull() {
			executeAndReset()
			processQueue() // TODO top queue only
		}
	}


	// flush items in batch.
	executeAndReset()

	// empty the queue
	flushQueue()
	// for qID != 0 {
	// 	processQueue()
	// 	executeAndReset()
	// }


	// reduce buckets into total
	// total =  bucket[0] + 2*bucket[1] + 3*bucket[2] ... + n*bucket[n-1]

	var runningSum, total {{ $.TJacobianExtended }}
	runningSum.setInfinity()
	total.setInfinity()
	for k := len(buckets) - 1; k >= 0; k-- {
		if bucketSet[k]  {
			runningSum.addMixed(&buckets[k])
		}
		if !bucketsJE[k].ZZ.IsZero() {
			runningSum.add(&bucketsJE[k])
		}
		total.add(&runningSum)
	}

	chRes <- total

}

// we declare the buckets as fixed-size array types
// this allow us to allocate the buckets on the stack
{{- range $c :=  $.CRange}}
{{- if gt $c 9}}
type bucket{{ $.TAffine }}C{{$c}} [1<<({{$c}}-1)]{{ $.TAffine }}
{{- end}}
{{- end}}


// buckets: array of {{ $.TAffine }} points of size 1 << (c-1)
type ib{{ $.TAffine }} interface {
	{{- range $i, $c :=  $.CRange}}
	{{- if gt $c 9}}
	bucket{{ $.TAffine }}C{{$c}} {{- if not (last $i $.CRange)}} | {{- end}}
	{{- end}}
	{{- end}}
}

// array of coordinates {{ $.CoordType }}
type c{{ $.TAffine }} interface {
	{{- range $i, $c :=  $.CRange}}
	{{- if gt $c 9}}
	c{{ $.TAffine }}C{{$c}} {{- if not (last $i $.CRange)}} | {{- end}}
	{{- end}}
	{{- end}}
}

// buckets: array of {{ $.TAffine }} points (for the batch addition)
type p{{ $.TAffine }} interface {
	{{- range $i, $c :=  $.CRange}}
	{{- if gt $c 9}}
	p{{ $.TAffine }}C{{$c}} {{- if not (last $i $.CRange)}} | {{- end}}
	{{- end}}
	{{- end}}
}

// buckets: array of *{{ $.TAffine }} points (for the batch addition)
type pp{{ $.TAffine }} interface {
	{{- range $i, $c :=  $.CRange}}
	{{- if gt $c 9}}
	pp{{ $.TAffine }}C{{$c}} {{- if not (last $i $.CRange)}} | {{- end}}
	{{- end}}
	{{- end}}
}

// buckets: array of {{ $.TAffine }} queue operations (for the batch addition)
type qOps{{ $.TAffine }} interface {
	{{- range $i, $c :=  $.CRange}}
	{{- if gt $c 9}}
	q{{ $.TAffine }}C{{$c}} {{- if not (last $i $.CRange)}} | {{- end}}
	{{- end}}
	{{- end}}
}


{{- range $c :=  $.CRange}}
{{if gt $c 9}}
// batch size {{batchSize $c}} when c = {{$c}}
type c{{ $.TAffine }}C{{$c}} [{{batchSize $c}}]{{ $.CoordType }}
type p{{ $.TAffine }}C{{$c}} [{{batchSize $c}}]{{ $.TAffine }}
type pp{{ $.TAffine }}C{{$c}} [{{batchSize $c}}]*{{ $.TAffine }}
type q{{ $.TAffine }}C{{$c}} [{{batchSize $c}}]batchOp{{ $.TAffine }}
{{- end}}
{{- end}}


{{end }}

{{- range $c :=  $.G1.CRange}}
type bitSetC{{$c}} [1<<({{$c}}-1)]bool
{{- end}}

type bitSet interface {
	{{- range $i, $c :=  $.G1.CRange}}
	bitSetC{{$c}} {{- if not (last $i $.G1.CRange)}} | {{- end}}
	{{- end}}
}
