
import (	"math/big"

	"github.com/consensys/gnark-crypto/ecc/{{ .Name }}/fr"
)

// decompose interpret rawBytes as a bigInt x in big endian,
// and returns the digits of x (from LSB to MSB) when x is written
// in basis modulo.
func decompose(rawBytes []byte) []fr.Element {

	rawBigInt := big.NewInt(0).SetBytes(rawBytes)
	modulo := fr.Modulus()

	// maximum number of chunks that a function
	maxNbChunks := len(rawBytes) / fr.Bytes

	res := make([]fr.Element, 0, maxNbChunks)
	var tmp fr.Element
	var zero big.Int

	for rawBigInt.Cmp(&zero) > 0 {
		tmp.SetBigInt(rawBigInt) // tmp <- rawBitInt [r]
		res = append(res, tmp)
		rawBigInt.Div(rawBigInt, modulo)
	}

	return res
}
